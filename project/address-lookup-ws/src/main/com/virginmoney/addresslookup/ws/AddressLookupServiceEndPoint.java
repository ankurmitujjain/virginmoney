/**
 * Service endpoint for address searches.
 */


package com.virginmoney.addresslookup.ws;

import java.util.List;
import javax.annotation.Resource;
import javax.jws.WebMethod;
import javax.jws.WebParam;
import javax.jws.WebResult;
import javax.xml.ws.WebServiceContext;
import org.apache.log4j.Logger;
import org.apache.log4j.NDC;
import org.springframework.validation.Errors;
import org.springframework.validation.ObjectError;
import com.virginmoney.addresslookup.business.AddressSearchParameters;
import com.virginmoney.addresslookup.business.AddressList;
import com.virginmoney.addresslookup.business.AbstractAddress;
import com.virginmoney.addresslookup.messages.*;
import com.virginmoney.addresslookup.service.AddressSearchService;
import com.virginmoney.addresslookup.service.AddressSearchServiceImpl;
import com.virginmoney.addresslookup.validators.ValidationException;
import com.virginmoney.addresslookup.util.TimingUtil;
import com.virginmoney.addresslookup.util.ServiceUtil;
import net.sf.dozer.util.mapping.MapperIF;

/**
   Main endpoint class for the Service .
   <p/><p/>
   Because the request parameters are defined in {@link AddressLookupRequest} which is generated by JAX-WS and
   thus cannot be edited the parameters are repeated here.
    <p/><p/>
   Please also refer to the project overview Javadoc page for more information.

   </pre>
          <table border="1" cellpadding="5">
           <thead>
              <td width="100"><b><font size="+1">Parameter</font></b></td>
              <td width="100"><b><font size="+1">Values</font></b></td>
              <td><b><font size="+1">Required</font></b></td>
              <td width="100"><b><font size="+1">Default</font></b></td>
              <td>Comments</>
           </thead>
           <tbody>
           <tr>
                 <td><b>searchPostcode</b></td>
                 <td>The postcode to be searched for</td>
                 <td>Mandatory</td>
                 <td>n/a</td>
                  <td>All addresses which match the supplied value will be returned</td>
           </tr>
           <tr>
                 <td><b>searchBuilding</b></td>
                 <td>Bulding name to sort results by</td>
                 <td>Optional</td>
                 <td>null</td>
                 <td>If supplied, addresses which match this value will be sorted to the start of the results. If not provided the results will be in the order returned by the search provider</td>
           </tr>
           <tr>
                 <td><b>serviceProvider</b></td>
                 <td>See comments </td>
                 <td>Optional</td>
                 <td>PostcodeAnywhere</td>
                 <td>Service provider to be used. See {@link com.virginmoney.addresslookup.business.AddressSearchParameters.ServiceProviders} for a list of valid values. Defaults to {@link com.virginmoney.addresslookup.business.AddressSearchParameters.ServiceProviders#PostcodeAnywhere} if not supplied   </td>
           </tr>
           <tr>
                 <td><b>resultFormat</b></td>
                 <td>See below </td>
                 <td>Optional</td>
                 <td>DEFAULT</td>
                 <td>Address style to be used when returning the results of the search; see table below for possible values.   </td>
           </tr>
           <tr>
                 <td><b>returnOnlyMatchingAddresses</b></td>
                 <td>true or false</td>
                 <td>Optional</td>
                 <td>false</td>
                 <td>If true, and a value for <b>searchBuilding</b> is supplied, then only results which match <b>searchBuilding</b> will be returned</td>
           </tr>
           <tr>
                 <td><b>sortMatchingAddresses</b></td>
                 <td>true or false</td>
                 <td>Optional</td>
                 <td>true</td>
                 <td>If true, and a value for <b>searchBuilding</b> is supplied, then results which match <b>searchBuilding</b> will be sorted to the beginning of the results list</td>
           </tr>
           <tr>
                 <td><b>returnPAFData</b></td>
                 <td>true or false</td>
                 <td>Optional</td>
                 <td>false</td>
                 <td>Indicates if unformatted PAF address data (see {@link com.virginmoney.addresslookup.business.PAFData}) is to be returned. Not available for all providers (see Overview page). </td>
           </tr>
           </tbody>
          </table>
   </pre>
   <p>Supported result formats. Note that empty fields will be returned when the address style chosen does not require them.</p>
<p>  See {@link AddressLookupRequest} for the request structure,  {@link AddressLookupResponse} for the full response
 structure and {@link Address} for the fields available in an individual address result</p>
    <table border="1" cellpadding="5">
           <thead>
              <td><b><font size="+1">Format code</font></b></td>
              <td><b><font size="+1">Description</font></b></td>
              <td><b><font size="+1">Supported providers</font></b></td>
           </thead>
           <tbody>
           <tr>
                 <td><b>null</b></td>
                 <td>defaults to STYLE1, as described below</td>
                 <td>All</td>
           </tr>
           <tr>
                 <td><b>STYLE1</b></td>
                 <td>4 lines of address, plus postcode, plus optional PAF data (if supported by provider).
 Organisation names will placed on Address line 1, on their own.</td>
                 <td>All</td>
           </tr>
           <tr>
                 <td><b>STYLE2</b></td>
                 <td>2 lines of address, plus post town, county and postcode, plus optional PAF data (if supported by
 provider). Organisation names will placed in a field on their own.</td>
                 <td>Any provider which supports PAF data (see Overview page).</td>
           </tr>
           </tbody>
          </table>

 */

@javax.jws.WebService(endpointInterface = "com.virginmoney.addresslookup.messages.AddressLookupServicePortType",
        targetNamespace = "http://www.virginmoney.com/vmDataTypes/", serviceName = "AddressLookupService",
        name = "AddressLookupService")
public class AddressLookupServiceEndPoint implements AddressLookupServicePortType {
    private Logger logger = Logger.getLogger(this.getClass());

    // Service class used to perform an address search - populated via spring
    private AddressSearchService addressSearchService = new AddressSearchServiceImpl();

    // Dozer mapper - populated via spring
    MapperIF mapper;

    @Resource
    WebServiceContext wsContext;

    @WebMethod
    @WebResult(name = "postcodeLookupResponse",
            targetNamespace = "http://www.virginmoney.com/vmDataTypes/",
            partName = "result")
    public AddressLookupResponse addressLookup(@WebParam(name = "postcodeLookupRequest",
            targetNamespace = "http://www.virginmoney.com/vmDataTypes/",
            partName = "lookupRequest")
    AddressLookupRequest lookupRequest) throws AddressLookupException
    {
        return doAddressLookup(lookupRequest);
    }

    /**
     * Handles the actual address search.
     *
     * @param lookupRequest The search parameters.
     * @return a list of addresses which match the search criteria.
     * @throws AddressLookupException
     */
    private AddressLookupResponse doAddressLookup(AddressLookupRequest lookupRequest) throws AddressLookupException {
        // push a logging 'Nested Diagnostic Context' value into the Log4j system so that each message from this
        //  particular execution has a unique id attached to it. Because of the lack of a unique request or application
        // id we use the hashcode of the request object, this allows different searches for the same postcode to be
        // seperated in the log file.
        NDC.remove();
        NDC.push("Postcode=" + lookupRequest.getSearchPostcode() + " hash=" + lookupRequest.hashCode());

        long startTime = System.currentTimeMillis();

        if (logger.isTraceEnabled()) {
            logger.trace("addressLookup() request=\n" + ServiceUtil.messageToString(lookupRequest,true));
        }

        logger.debug("addressLookup() searching for postcode=\"" + lookupRequest.getSearchPostcode() + "\"" +
                " building name=\"" + lookupRequest.getSearchBuilding() + "\"" +
                " provider=\"" + lookupRequest.getServiceProvider()  + "\"" +
                " format=\"" + lookupRequest.getResultFormat()  + "\"" +
                " sortMatchingAddresses=" + lookupRequest.isSortMatchingAddresses() +
                " returnOnlyMatchingAddresses=" + lookupRequest.isReturnOnlyMatchingAddresses() +
                " returnPAFData=" + lookupRequest.isReturnPAFData());

        // parse the address provider into the enum; in the event of an error use the default value
        AddressSearchParameters.ServiceProviders serviceProvider;
        try {
            serviceProvider = AddressSearchParameters.ServiceProviders.valueOf(lookupRequest.getServiceProvider().value());
        }
        catch(IllegalArgumentException e) {
            logger.debug("Illegal argument passed to enum.", e);
            serviceProvider = null;
        }
        logger.trace("Provider text=" + lookupRequest.getServiceProvider() + " enum=" + serviceProvider);

        // parse the result format into the enum; in the event of an error use the default value
        AddressSearchParameters.ResultFormats resultFormat;
        try {
            resultFormat = AddressSearchParameters.ResultFormats.valueOf(lookupRequest.getResultFormat().value());
        }
        catch (IllegalArgumentException e) {
            logger.debug("Illegal argument passed to enum.", e);
            resultFormat = null;
        }
        logger.trace("Result format text=" + lookupRequest.getResultFormat() + " enum=" +  resultFormat);

        // explicitly set the 'return only matching results' rule if the relevant boolean value is set,
        // otherwise leave it null.
        AddressSearchParameters.ReturnMatchingResultRules returnMatchingResultRule = null;
        if (lookupRequest.isReturnOnlyMatchingAddresses() != null && lookupRequest.isReturnOnlyMatchingAddresses()) {
            returnMatchingResultRule = AddressSearchParameters.ReturnMatchingResultRules.onlyMatchingResults;
        }

        // explicitly set the 'sort matching results' rule if the relevant boolean value is set,
        // otherwise leave it null. The default is true, so explicitly check for false
        AddressSearchParameters.SortMatchingResultRules sortMatchingResultRule = null;
        if (lookupRequest.isSortMatchingAddresses() != null && !lookupRequest.isSortMatchingAddresses()) {
            sortMatchingResultRule = AddressSearchParameters.SortMatchingResultRules.dontSort;
        }

        // explicitly set the 'return PAF data' rule if the relevant boolean value is set,
        // otherwise leave it null.
        AddressSearchParameters.ReturnPAFDataRules returnPAFDataRule = null;
        if (lookupRequest.isReturnPAFData() != null && lookupRequest.isReturnPAFData()) {
            returnPAFDataRule = AddressSearchParameters.ReturnPAFDataRules.returnPAFData;
        }

        AddressSearchParameters searchParameters = new AddressSearchParameters(lookupRequest.getSearchPostcode(),
                lookupRequest.getSearchBuilding(),
                resultFormat,
                serviceProvider,
                returnMatchingResultRule,
                sortMatchingResultRule,
                returnPAFDataRule);

        logger.debug("Created searchParameters=" + searchParameters);

        logger.trace("creating response");
        AddressLookupResponse response = new AddressLookupResponse();
        response.setSearchPostcode(searchParameters.getSearchPostcode());
        response.setSearchBuilding(searchParameters.getSearchBuilding());

        try {
            logger.trace("Converting business provider back to message provider : business value=" +
                    searchParameters.getServiceProvider().toString());
            response.setServiceProvider(ServiceProviders.fromValue(searchParameters.getServiceProvider().toString()));
            logger.trace("Converted business provider back to message provider :  message value=" +
                    response.getServiceProvider().toString());
        }
        catch (IllegalArgumentException e) {
            logger.info("Couldnt convert business service provider back to a message object :  local provider=" +
             searchParameters.getServiceProvider().toString());
        }

        try {
            logger.trace("Converting business result format back to message provider : business value=" +
                    searchParameters.getResultFormat().toString());
            response.setResultFormat(ResultFormats.fromValue(searchParameters.getResultFormat().toString()));
            logger.trace("Converted business result format back to message provider :  message value=" +
                    response.getResultFormat().toString());
        }
        catch (IllegalArgumentException e) {
            logger.info("Couldnt convert business service provider back to a message object :  local provider=" +
             searchParameters.getServiceProvider().toString());
        }
        
        response.setReturnOnlyMatchingAddresses(searchParameters.returnOnlyMatchingResults());
        response.setSortMatchingAddresses(searchParameters.sortMatchingResults());
        response.setReturnPAFData(searchParameters.returnPAFData());
        response.setResultCount(0);
        logger.trace("doing search");

        try {

            AddressList searchResults = addressSearchService.doAddressSearch(searchParameters);

            if (searchResults.getAddresses().size() > 0) {
                List<com.virginmoney.addresslookup.messages.Address> responseAddresses =
                        mapPostcodeLookupReponseToMessage(searchResults.getAddresses(), response);

                response.setResultCount(responseAddresses.size());
            }
        }
        catch (ValidationException ve) {
            logger.error("addressLookup caught validation exception searching for postcode " + searchParameters.getSearchPostcode() + " : " + ve);
            ErrorList errors = buildErrorListFromValidationErrors(ve.getErrors());
            response.setErrors(errors);
            NDC.remove();// remove the logging reference
        }
        catch (Exception e) {
            logger.error("addressLookup caught exception searching for postcode " + searchParameters.getSearchPostcode() + " : " + e, e);
            AddressLookupException newException = createAddressLookupException("searching for postcode " + searchParameters.getSearchPostcode(),e);
            logger.error("addressLookup rethrowing as " + newException, newException);

            NDC.remove();// remove the logging reference
            throw  newException;// rethrow the error
        }

        long finishTime = System.currentTimeMillis();
        logger.info("address-lookup-ws Endpoint finished search       : elapsed=" +
                TimingUtil.formatElapsedSeconds(startTime,finishTime) + " result count=" + response.getResultCount() +
                " paameters=" + searchParameters);


//        if (logger.isTraceEnabled()) {
//            logger.trace("addressLookup() response=\n" + ServiceUtil.messageToString(response,true));
//        }


        NDC.remove();// remove the logging reference

        return response;
    }

    private List<com.virginmoney.addresslookup.messages.Address> mapPostcodeLookupReponseToMessage(List<AbstractAddress> lookupResults,
                                                                AddressLookupResponse response)
    {
        List<com.virginmoney.addresslookup.messages.Address> messageAddresses = response.getAddresses();
        messageAddresses.clear();

        // map the search results to the message objects
        for (AbstractAddress responseAbstractAddress : lookupResults) {
            com.virginmoney.addresslookup.messages.Address messageAddress = new com.virginmoney.addresslookup.messages.Address();
            mapper.map(responseAbstractAddress,messageAddress);
            messageAddresses.add(messageAddress);
        }

        return messageAddresses;
    }

    private AddressLookupException createAddressLookupException(String when,Exception e){

        logger.error("createAddressLookupException() creating exception for " + e,e);

        ServiceFault faultInfo = new ServiceFault();
        StringBuffer stackTrace = new StringBuffer();
        final String newline = System.getProperty("line.separator");

        for(StackTraceElement ste : e.getStackTrace()) {
            stackTrace.append(ste.toString()).append(newline);
        }

        faultInfo.setErrorDescription(stackTrace.toString());
        AddressLookupException newException = new AddressLookupException("Error in Address Lookup Service when " + when + " :"  +e.getMessage(), faultInfo);
        return newException;
    }

    /**
     * Build a jax error list ojbect from a list of errors returned by a validation exception.
     *
     * @param errors a list of validation errors
     *
     * @return a jax error list object that can be put in a response.
     */
    private ErrorList buildErrorListFromValidationErrors(Errors errors) {
        ErrorList list = new ErrorList();
        List<ErrorMessage> messages = list.getErrors();

        List<ObjectError> errorList = (List<ObjectError>)errors.getAllErrors();

        for (ObjectError err : errorList) {
            ErrorMessage msg = new ErrorMessage();
            msg.setErrorMessageKey(err.getCode());
            msg.setErrorDefaultMessage(err.getDefaultMessage());

            messages.add(msg);
        }

        return list;
    }

    /**
     * Allows the address search business logic to be injected by Spring at runtime.
     * @param addressSearchService  the address search business logic implemntation.
     */
    public void setAddressSearchService(AddressSearchService addressSearchService) {
        this.addressSearchService = addressSearchService;
    }

    /**
     * Allows a Dozer bean mapper to be injected by Spring at runtime.
     * @param mapper a Dozer bean mapper.
     */
    public void setMapper(MapperIF mapper) {
        this.mapper = mapper;
    }



}
